# DendroSym

A symbolic framework for generating efficient C++ code with the Dendro framework for complicated simulation systems.

## About DendroSym

To come.

## Installation

This repository is installed as a Python package. The project is not on PyPi.org, so the repository will need to be cloned and installed. It is recommended that this package is installed in a virtual environment and not on the system as a whole.

1. Clone the repository and enter the folder:

    ```sh
    git clone https://github.com/paralab/SymPyGR
    cd SymPyGR
    ```

    This step can be skipped if you follow Method 3 for installing the repository.
2. Install the repository:

    **Method 1** (easiest, but any changes require reinstallation)
    ```sh
    pip3 install .
    ```

    **Method 2** (any changes made to the files in the folder are immediately recognized and used)
    ```sh
    pip3 install -e .
    ```
    The `-e` flag tells `pip` that this is an "editable" install which allows active development of the project.

    **Method 3**
    ```sh
    pip3 install git+https://github.com/paralab/SymPyGR
    ```

    For this method, the `-e` flag can also be placed after the word `install` to mimic Method 2's editable mode.

    Installation of the repository should handle all dependencies as well.


## Usage

More information to come. A sample Python file will be included soon.

---

## Legacy SymPyGR 

What follows is the original documentation of SymPyGR. The original code can be found in the `master-legacy` branch since the project has taken a new direction.

---

SymPy based framework for optimized code generation for BSSN formulation of Einstein equation for heterogeneous platforms. 

Dendro is an adaptive meshing framework that enables solving large-scale
computational problems on octree-refined meshes. The current version of dendro and
dendro_sym , handle adaptivity by decomposing the domain into a collection of small
regular blocks (uniformly refined), on which the code corresponding to the PDE are
automatically generated (C/C++) from the symbolic expressions. While the overall
framework works currently, there are several areas for improving performance and
portability and these are the possible research topics. Note that although dendro
supports distributed computing on large clusters, these improvements are only
required at the single-node and possibly single-thread level, as the blocks generated by
dendro are typically 16^3 to 256^3 in size. The topics listed below are tagged with the key
focus areas, gpu, openmp, simd, graph. 

* graph: Sympy produces an expression tree that is sufficiently simplified. But,
there are several repeated expressions within this tree that can be simplified by
factoring out these expressions and evaluating them only once. The main focus of
this task would be to develop algorithms for extracting common sub-expressions
within sympy. This would most likely be done in python.
* openmp, gpu Dendro produces a list of blocks that need to be scheduled across
threads and GPUs. We currently support simple scheduling via openmp.
Performance and load-balancing can be improved significantly by better
scheduling of the blocks. Of particular interest is to device methods to scheduled
blocks dynamically between GPUs and CPUs. This might have to be done in C/C++
to schedule the blocks. This C++ code can potentially be autogenerated from the
python code.
* gpu, simd As previously mentioned, the current implementation generates C++
code from the sympy expression trees. A very important contribution would be to
add python code to generate for different architecture targets, such as
1. default: pure C/C++ code
2. avx2: SIMD code targeting 256-bit wide AVX2 architectures
3. avx512: SIMD code targeting 512-bit wide architectures, such as the Xeon PHI
4. cuda: CUDA code targeting nVidia GPUs, possibly with options targeting
different generations.
5. openCL, openACC : and others.
